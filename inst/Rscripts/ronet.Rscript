#!/bin/tcsh /SOFT/bi/apps/R/bdeRscript

suppressMessages(library(ribiosUtils))
suppressMessages(library(ribiosArg))

## constants
MAXCONN.DEFAULT <- 0L
## supported out formats: defined as igraph::write.graph
SUPP.OUT.FORMATS <- c("edgelist", "pajek", "ncol", "lgl", "graphml", "dimacs", "gml", "dot")

infile <- getArg("infile", onlyArg=NULL, missingArg=NULL)
outfile <- getArg("outfile", onlyArg=NULL, missingArg=NULL)
maxconn <- getArg("maxConnector", onlyArg=MAXCONN.DEFAULT, missingArg=MAXCONN.DEFAULT)
## level.limit = maxconn+1, since it measures the path step length
level.limit <- parseNumVec(maxconn, expLen=1L, failVal=MAXCONN.DEFAULT)+1L
removeConnectorEdges <- existArg("noConnectorEdges")

getHelp <- existArg("h") | existArg("help")

if(is.null(infile) || is.null(outfile) || getHelp) {
  qqmsg(paste("\nUsage:",
              scriptName(),
              "[-maxConnector INT] -infile FILE -outfile FILE\n",
              "Mandatory parameter:\n",
              "-infile FILE\tInput Entrez GeneIDs, one GeneID per line\n",
              "-outfile FILE\tOutput file. By default outputs are printed in standard output, e.g. screen.\n",
              "Optional parameters:\n",
              "-maxConnector INT\tMax number of connectors in network expansion. Default:0 (no network expansion).\n",
              "-noConnectorEdges\tIf specified, edges between connectors are removed. Default: off (edges among connectors are returned).\n",
              sep=" "))
}
## OUTPUT
outformat <- extname(outfile)
if(is.na(outformat) || !outformat %in% SUPP.OUT.FORMATS) {
  warning("Outfile format not detected. GML format is used\n",
          "Please use one of the following formats as file name extension\n\t",
          paste(SUPP.OUT.FORMATS, collapse=", "))
  outformat <- "gml"
}

## INPUT
if(!file.exists(infile))
  qqmsg("ERROR: 'infile' not found\n", status=1L)
geneids <- readLines(infile)
geneids <- unique(geneids[!is.na(geneids) & geneids!="NA"])


## annotation
libordie(ribiosAnnotation)

## build interaction network
sql <- paste("SELECT",
             "INT_ID as ID, GENE1, GENE_SYM1, INT_TYPE as type, EFFECT, GENE2, GENE_SYM2, SOURCE",
             "FROM bi2.ronet_intdb_snap",
             "WHERE SOURCE IN ('KEGG','REACTOME', 'ariadne-RESNET6')",
             sep=" ")
all.tbl <- querydb(sql,db="bia", user="biread", password="biread")
all.tbl <- subset(all.tbl, !is.na(GENE1) & !is.na(GENE2))
ftM <- as.matrix(all.tbl[,c("GENE1", "GENE2")])
ftM.isUniq <- !duplicated(ftM)
ftM <- ftM[ftM.isUniq,]
## interaction type
ftM.type <- all.tbl[,"TYPE"]
hasEffect <- !is.na(all.tbl[,"EFFECT"])
ftM.type[hasEffect] <- paste(ftM.type[hasEffect], all.tbl[hasEffect, "EFFECT"], sep="_")
ftM.type <- ftM.type[ftM.isUniq]

## graph library
libordie(RBGL)
Gd <- ftM2graphNEL(ftM, edgemode="directed")
edgeDataDefaults(Gd, "label") <- ""
edgeData(Gd, from=all.tbl[ftM.isUniq, "GENE1"],
         to=all.tbl[ftM.isUniq, "GENE2"],
         attr="label") <- ftM.type

## validate input nodes
input.ids <- intersect(nodes(Gd), geneids)
missingNodes <- setdiff(geneids, c(NA, nodes(Gd)))
if(length(input.ids)==0)
  qqmsg("No ids found in the interaction database.", status=2L)

## find subnetwork
if(level.limit<=1L) {
  expand.ids <- input.ids
} else {
  G <- ugraph(Gd) ## very slow (ca. 60s)
  
  gene.start <- rep(input.ids[-length(input.ids)],
                    (length(input.ids)-1):1)
  gene.end <- unlist(sapply(1:(length(input.ids)-1),
                            function(x) input.ids[(x+1):length(input.ids)]))
  
  if(level.limit <=3) {
    input.nei <- adj(G, input.ids)
    neighbors <- unique(c(input.ids, unlist(input.nei)))
    nG <- subGraph(neighbors, G)
    gs <- sp.between(nG, start=gene.start, finish=gene.end)
  } else {
    gs <- sp.between(G, start=gene.start, finish=gene.end)
  }
  
  gs.levels <- sapply(gs, function(x) x$length)
  gs.outLevel <- is.na(gs.levels) | gs.levels > level.limit
  gs.raw <- gs
  gs <- gs.raw[!gs.outLevel]
  
  expand.idList <- sapply(gs, function(x) x$path_detail)
  expand.ids <- unique(c(input.ids, unlist(expand.idList)))
}

expandG <- subGraph(expand.ids, Gd)
fullExpandG <- addNode(missingNodes, expandG)

if(removeConnectorEdges) {
  linkers <- setdiff(expand.ids, geneids)
  full.edges <- edges(fullExpandG)
  edge.labels <- sapply(seq(along=full.edges),
                        function(x) paste(names(full.edges)[x], full.edges[[x]], sep="|"))
  edge.pairs <- strsplit(unlist(edge.labels), "\\|")
  linker.edges <- sapply(edge.pairs, function(x) length(x)==2L & all(x %in% linkers))
  if(any(linker.edges)) {
    linker.froms <- sapply(edge.pairs[linker.edges], "[[", 1L)
    linker.tos <- sapply(edge.pairs[linker.edges], "[[", 2L)
    fullExpandG <- removeEdge(from=linker.froms, to=linker.tos, fullExpandG)
  }
}

## visualization for debugging
if(vis <- FALSE){
  libordie(Rgraphviz)
  ncols <- makeNodeAttrs(fullExpandG, fillcolor=ifelse(nodes(fullExpandG) %in% geneids, "lightblue", "orange"))
  plot(fullExpandG, nodeAttrs=ncols)
}

## output
libordie(igraph)
outG <- igraph.from.graphNEL(fullExpandG)
outG.names <- get.vertex.attribute(outG, "name")
id2sym <- c(all.tbl$GENE_SYM1, all.tbl$GENE_SYM2)
names(id2sym) <- c(all.tbl$GENE1, all.tbl$GENE2)
V(outG)$label <- unname(id2sym[outG.names])
outG.missLabel <- is.na(V(outG)$label)
V(outG)$label[outG.missLabel] <- outG.names[outG.missLabel]
V(outG)$isInput <- as.integer(outG.names %in% geneids)

## customed export function for GML
exportGML <- function(graph, filename) {
  file <- file(filename, "w")
  cat("Creator \"ribiosNetwork\"\n", file=file)
  cat("Version 1.0\n", file=file)
  cat("graph\n[\n", file=file)
  cat("  directed", as.integer(is.directed(graph)), "\n", file=file)
  for (i in seq_len(vcount(graph))) {
    cat("  node\n  [\n", file=file)
    cat("    id", i-1, "\n", file=file)
    cat("    name \"", V(graph)$name[i], "\"\n", file=file, sep="")
    cat("    label \"", V(graph)$label[i], "\"\n", file=file, sep="")
    cat("    graphics\n    [\n", file=file)
    cat("      w 45 \n", file=file, sep="")
    cat("      h 45 \n", file=file, sep="")
    cat("      type \"", ifelse(V(graph)$isInput[i]==1, "ellipse", "diamond"), "\"\n", file=file, sep="")
    cat("    ]\n", file=file)
    cat("  ]\n", file=file)
  }
  el <- get.edgelist(graph, names=FALSE)
  for (i in seq_len(nrow(el))) {
    elabel <- E(graph)$label[i]
    cat("  edge\n  [\n", file=file)
    cat("    source", el[i,1], "\n", file=file)
    cat("    target", el[i,2], "\n", file=file)
    cat("    label \"",  elabel, "\"\n", file=file, sep="")
    cat("    graphics\n    [\n", file=file)
    cat("      source_arrow 0\n", file=file, sep="")
    target.arrow <- 12
    if(grepl("positive", elabel, ignore.case=TRUE)) {
      target.arrow <- 3
    } else if (grepl("negative", elabel, ignore.case=TRUE)) {
      target.arrow <- 15
    }
    cat("      target_arrow ", target.arrow, "\n", file=file, sep="")
    cat("    ]\n", file=file)
    cat("  ]\n", file=file)
  }
  cat("]\n", file=file)
  close(file)
}

if(outformat=="gml") {
  exportGML(outG, file=outfile)
} else {
  write.graph(outG, file=outfile, format=outformat)
}

qqmsg(status=0L)
